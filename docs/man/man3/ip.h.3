.TH "includes/ip.h" 3 "Version v01.01r" "libcnet" \" -*- nroff -*-
.ad l
.nh
.SH NAME
includes/ip.h
.SH SYNOPSIS
.br
.PP
\fR#include <sys/cdefs\&.h>\fP
.br
\fR#include <sys/types\&.h>\fP
.br
\fR#include <stdbool\&.h>\fP
.br
\fR#include <netinet/in\&.h>\fP
.br
\fR#include <arpa/inet\&.h>\fP
.br
\fR#include <stdlib\&.h>\fP
.br
\fR#include <string\&.h>\fP
.br
\fR#include <stdio\&.h>\fP
.br
\fR#include 'utils/buffer\&.h'\fP
.br
\fR#include 'utils/net\&.h'\fP
.br
\fR#include 'utils/version\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBh_echo_t\fP"
.br
.ti -1c
.RI "struct \fBh_mtu_t\fP"
.br
.ti -1c
.RI "union \fBh_data_t\fP"
.br
.ti -1c
.RI "struct \fBIcmpHeader\fP"
.br
.ti -1c
.RI "struct \fBIcmpPacket\fP"
.br
.ti -1c
.RI "struct \fBUdpHeader\fP"
.br
.ti -1c
.RI "struct \fBUdpPacket\fP"
.br
.ti -1c
.RI "struct \fBTcpOption\fP"
.br
.ti -1c
.RI "struct \fBControlBits\fP"
.br
.ti -1c
.RI "struct \fBTcpHeader\fP"
.br
.ti -1c
.RI "struct \fBTcpPacket\fP"
.br
.ti -1c
.RI "struct \fBPseudoHeader\fP"
.br
.ti -1c
.RI "struct \fBIpHeader\fP"
.br
.ti -1c
.RI "struct \fBIpPacket\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBICMP_HEADER_MAX_SIZE\fP   0x08"
.br
.ti -1c
.RI "#define \fBICMP_ECHO_REPLY_TYPE\fP   0x00"
.br
.ti -1c
.RI "#define \fBICMP_DESTINATION_UNREACHABLE_TYPE\fP   0x03"
.br
.ti -1c
.RI "#define \fBICMP_SOURCE_QUENCH_TYPE\fP   0x04"
.br
.ti -1c
.RI "#define \fBICMP_REDIRECT_TYPE\fP   0x05"
.br
.ti -1c
.RI "#define \fBICMP_ECHO_TYPE\fP   0x08"
.br
.ti -1c
.RI "#define \fBICMP_TIME_EXCEEEDED_TYPE\fP   0x0b"
.br
.ti -1c
.RI "#define \fBICMP_PARAMETER_PROBLEM_TYPE\fP   0x0c"
.br
.ti -1c
.RI "#define \fBICMP_INFORMATION_REQUEST_TYPE\fP   0x0f"
.br
.ti -1c
.RI "#define \fBICMP_INFORMATION_REPLY_TYPE\fP   0x10"
.br
.ti -1c
.RI "#define \fBICMP_NET_UNREACHABLE_CODE\fP   0x00"
.br
.ti -1c
.RI "#define \fBICMP_HOST_UNREACHABLE_CODE\fP   0x01"
.br
.ti -1c
.RI "#define \fBICMP_PROTOCOL_UNREACHABLE_CODE\fP   0x02"
.br
.ti -1c
.RI "#define \fBICMP_PORT_UNREACHABLE_CODE\fP   0x03"
.br
.ti -1c
.RI "#define \fBICMP_FRAGMENTATION_NEEDED_CODE\fP   0x04"
.br
.ti -1c
.RI "#define \fBICMP_SOURCE_ROUTE_FAILED_CODE\fP   0x05"
.br
.ti -1c
.RI "#define \fBICMP_ECHO_CODE\fP   0x0"
.br
.ti -1c
.RI "#define \fBICMP_PAYLOAD_MAXIMUM_SIZE\fP   0xffe3"
.br
.ti -1c
.RI "#define \fBUDP_HEADER_SIZE\fP   0x08"
.br
.ti -1c
.RI "#define \fBUDP_PAYLOAD_MAX_SIZE\fP   0xffe3"
.br
.ti -1c
.RI "#define \fBUDP_PSEUDO_HEADER_SIZE\fP   0x0c"
.br
.ti -1c
.RI "#define \fBTCP_NOT_SET\fP   0x00"
.br
.ti -1c
.RI "#define \fBTCP_FIN_SET\fP   0x01"
.br
.ti -1c
.RI "#define \fBTCP_SYN_SET\fP   0x02"
.br
.ti -1c
.RI "#define \fBTCP_RST_SET\fP   0x04"
.br
.ti -1c
.RI "#define \fBTCP_PSH_SET\fP   0x08"
.br
.ti -1c
.RI "#define \fBTCP_ACK_SET\fP   0x10"
.br
.ti -1c
.RI "#define \fBTCP_URG_SET\fP   0x20"
.br
.ti -1c
.RI "#define \fBTCP_ECE_SET\fP   0x40"
.br
.ti -1c
.RI "#define \fBTCP_CWR_SET\fP   0x80"
.br
.ti -1c
.RI "#define \fBTCP_PSEUDO_HEADER_SIZE\fP   0x0c"
.br
.ti -1c
.RI "#define \fBTCP_OPTIONS_MAX_SIZE\fP   0x14"
.br
.ti -1c
.RI "#define \fBTCP_OPTION_KIND_NOOP\fP   0x01"
.br
.ti -1c
.RI "#define \fBTCP_OPTION_KIND_MSS\fP   0x02"
.br
.ti -1c
.RI "#define \fBTCP_OPTION_KIND_WIN_SCALE\fP   0x03"
.br
.ti -1c
.RI "#define \fBTCP_OPTION_KIND_SACK_PERM\fP   0x04"
.br
.ti -1c
.RI "#define \fBTCP_OPTION_KIND_TIMESTAMP\fP   0x08"
.br
.ti -1c
.RI "#define \fBIPv4\fP   0x4"
.br
.ti -1c
.RI "#define \fBIPv6\fP   0x6"
.br
.ti -1c
.RI "#define \fBIP_HEADER_SIZE\fP   0x14"
.br
.ti -1c
.RI "#define \fBX_FLAG_NOT_SET\fP   0"
.br
.ti -1c
.RI "#define \fBD_FLAG_NOT_SET\fP   0"
.br
.ti -1c
.RI "#define \fBM_FLAG_NOT_SET\fP   0"
.br
.ti -1c
.RI "#define \fBD_FLAG_SET\fP   0x02"
.br
.ti -1c
.RI "#define \fBM_FLAG_SET\fP   0x01"
.br
.ti -1c
.RI "#define \fBIP_HEADER_FLAG\fP(_x,  _d,  _m)   (_x + _d + _m)"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_CS0\fP   0x00"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_CS1\fP   0x08"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_CS2\fP   0x10"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_CS3\fP   0x18"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_CS4\fP   0x20"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_CS5\fP   0x28"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_CS6\fP   0x30"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_CS7\fP   0x38"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF11\fP   0x0a"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF12\fP   0x0c"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF13\fP   0x0e"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF21\fP   0x12"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF22\fP   0x14"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF23\fP   0x16"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF31\fP   0x1a"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF32\fP   0x1c"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF33\fP   0x1e"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF41\fP   0x22"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF42\fP   0x24"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_AF43\fP   0x26"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_EF\fP   0x2e"
.br
.ti -1c
.RI "#define \fBIP_HEADER_DSCP_VOICE_ADMIT\fP   0x2c"
.br
.ti -1c
.RI "#define \fBIP_HEADER_ECN_NECT\fP   0x00"
.br
.ti -1c
.RI "#define \fBIP_HEADER_ECN_ECT1\fP   0x01"
.br
.ti -1c
.RI "#define \fBIP_HEADER_ECN_ECT0\fP   0x02"
.br
.ti -1c
.RI "#define \fBIP_HEADER_ECN_CE\fP   0x03"
.br
.ti -1c
.RI "#define \fBIP_HEADER_ICMP_PROTOCOL_CODE\fP   0x01"
.br
.ti -1c
.RI "#define \fBIP_HEADER_UDP_PROTOCOL_CODE\fP   0x11"
.br
.ti -1c
.RI "#define \fBIP_HEADER_TCP_PROTOCOL_CODE\fP   0x06"
.br
.ti -1c
.RI "#define \fBTTL_DEFAULT_VALUE\fP   0x80"
.br
.ti -1c
.RI "#define \fBIP_PAYLOAD_MAX_SIZE\fP   65515"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBIcmpHeader_new\fP (\fBIcmpHeader\fP *_hdr, const u_int8_t _type, const u_int8_t _code) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_setType\fP (\fBIcmpHeader\fP *_self, const u_int8_t _type) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_setCode\fP (\fBIcmpHeader\fP *_self, const u_int8_t _code) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_setChecksum\fP (\fBIcmpHeader\fP *_self, const u_int16_t _checksum) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_setGateway\fP (\fBIcmpHeader\fP *_self, const u_int32_t _gateway) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_setIdentifier\fP (\fBIcmpHeader\fP *_self, const u_int16_t _id) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_setSequenceNumber\fP (\fBIcmpHeader\fP *_self, const u_int16_t _seqnum) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_setNextHopMtu\fP (\fBIcmpHeader\fP *_self, const u_int16_t _mtu) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_printInfo\fP (const \fBIcmpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_printInfo_Unused\fP (const \fBIcmpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_printInfo_Redirect\fP (const \fBIcmpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_printInfo_Mtu\fP (const \fBIcmpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_createHeader_Unused\fP (\fBIcmpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_createHeader_Redirect\fP (\fBIcmpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_createHeader_Echo\fP (\fBIcmpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_createHeader_Mtu\fP (\fBIcmpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_encode\fP (const \fBIcmpHeader\fP *_self, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBByteBuffer\fP * \fBIcmpHeader_encode_b\fP (const \fBIcmpHeader\fP *_self) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBIcmpHeader_decode\fP (\fBIcmpHeader\fP *_hdr, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBIcmpPacket\fP * \fBIcmpPacket_new_tnc\fP (const u_int8_t _type, const u_int8_t _code) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBIcmpPacket\fP * \fBIcmpPacket_new\fP (const u_int8_t _type, const u_int8_t _code, const size_t _size) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBIcmpPacket_delete\fP (\fBIcmpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpPacket_fillHeader_Unused\fP (\fBIcmpPacket\fP *_self, const u_int16_t _checksum) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpPacket_fillHeader_Redirect\fP (\fBIcmpPacket\fP *_self, const u_int16_t _checksum, const u_int32_t _gateway) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpPacket_fillHeader_Echo\fP (\fBIcmpPacket\fP *_self, const u_int16_t _checksum, const u_int16_t _id, const u_int16_t _seqnum) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpPacket_fillHeader_Mtu\fP (\fBIcmpPacket\fP *_self, const u_int16_t _checksum, const u_int16_t _data) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpPacket_setHeader\fP (\fBIcmpPacket\fP *_self, \fBIcmpHeader\fP *_hdr) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpPacket_fillPayload\fP (\fBIcmpPacket\fP *_self, const char *_payload, const size_t _size) __attribute__((nonnull))"
.br
.ti -1c
.RI "size_t \fBIcmpPacket_getPacketSize\fP (const \fBIcmpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIcmpPacket_encode_b\fP (const \fBIcmpPacket\fP *_self, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBByteBuffer\fP * \fBIcmpPacket_encode\fP (const \fBIcmpPacket\fP *_self) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBIcmpPacket\fP * \fBIcmpPacket_decode\fP (\fBByteBuffer\fP *_buffer) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBUdpHeader_setSourcePort\fP (\fBUdpHeader\fP *_self, const u_int16_t _srcport) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBUdpHeader_setDestinationPort\fP (\fBUdpHeader\fP *_self, const u_int16_t _dstport) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBUdpHeader_setLength\fP (\fBUdpHeader\fP *_self, const u_int16_t _length) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBUdpHeader_setChecksum\fP (\fBUdpHeader\fP *_self, const u_int16_t _checksum) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBUdpHeader_printInfo\fP (const \fBUdpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBUdpHeader_encode\fP (const \fBUdpHeader\fP *_self, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBByteBuffer\fP * \fBUdpHeader_encode__\fP (const \fBUdpHeader\fP *_self) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBUdpHeader_decode\fP (\fBUdpHeader\fP *_self, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBUdpPacket\fP * \fBUdpPacket_new\fP () __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBUdpPacket\fP * \fBUdpPacket_new_s\fP (const size_t _size) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBUdpPacket_delete\fP (\fBUdpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBUdpPacket_fillHeader\fP (\fBUdpPacket\fP *_self, const u_int16_t _srcport, const u_int16_t _dstport, const u_int16_t _length, const u_int16_t _checksum) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBUdpPacket_setHeader\fP (\fBUdpPacket\fP *_self, \fBUdpHeader\fP *_hdr) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBUdpPacket_fillPayload\fP (\fBUdpPacket\fP *_self, const char *_data, const size_t _size) __attribute__((nonnull))"
.br
.ti -1c
.RI "size_t \fBUdpPacket_getPayloadSize\fP (const \fBUdpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "size_t \fBUdpPacket_getPacketSize\fP (const \fBUdpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBByteBuffer\fP * \fBUdpPacket_encode\fP (const \fBUdpPacket\fP *_self) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBUdpPacket_encode_b\fP (const \fBUdpPacket\fP *_self, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBUdpPacket\fP * \fBUdpPacket_decode\fP (\fBByteBuffer\fP *_buffer) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "struct \fBTcpOption\fP * \fBTcpOption_new\fP (const u_int8_t _kind, const u_int8_t _length, void *_value) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "struct \fBTcpOption\fP * \fBTcpOption_newMss\fP (u_int16_t _mss) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "struct \fBTcpOption\fP * \fBTcpOption_newSackPermitted\fP (void) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "struct \fBTcpOption\fP * \fBTcpOption_newNoOperation\fP (void) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "struct \fBTcpOption\fP * \fBTcpOption_newWindowScale\fP (u_int8_t _scale) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "struct \fBTcpOption\fP * \fBTcpOption_newTimestamps\fP (u_int32_t _tsval, u_int32_t _tsecr) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBTcpOptions_copy\fP (struct \fBTcpOption\fP **_src, struct \fBTcpOption\fP **_dst, const int _n) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpOptions_delete\fP (struct \fBTcpOption\fP **_opts, const int _n) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBControlBits_decode\fP (struct \fBControlBits\fP *_cbits, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBControlBits_toBin\fP (const struct \fBControlBits\fP *_cbits, char *_out) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBControlBits_fromValue\fP (const u_int8_t _bits, struct \fBControlBits\fP *_cbits) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setSourcePort\fP (\fBTcpHeader\fP *_self, u_int16_t _srcport) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setDestinationPort\fP (\fBTcpHeader\fP *_self, u_int16_t _dstport) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setSequenceNumber\fP (\fBTcpHeader\fP *_self, u_int32_t _seqnum) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setAcknowledgmentNumber\fP (\fBTcpHeader\fP *_self, u_int32_t _acknum) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setDataOffset\fP (\fBTcpHeader\fP *_self, u_int8_t _srcport) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setControlBits\fP (\fBTcpHeader\fP *_self, struct \fBControlBits\fP _cbits) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setCongestionWindowReducedFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_unsetCongestionWindowReducedFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setECNEchoFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_unsetECNEchoFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setUrgentPointerFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_unsetUrgentPointerFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setAcknowledgmentFieldFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_unsetAcknowledgmentFieldFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setPushFunctionFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_unsetPushFunctionFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setResetConnectionFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_unsetResetConnectionFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setSynchronizeFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_unsetSynchronizeFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setFinFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_unsetFinFlag\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setWindowSize\fP (\fBTcpHeader\fP *_self, u_int16_t _window) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setChecksum\fP (\fBTcpHeader\fP *_self, u_int16_t _checksum) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_setUrgentPointer\fP (\fBTcpHeader\fP *_self, u_int16_t _urgpntr) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_addTcpOption_o\fP (\fBTcpHeader\fP *_self, struct \fBTcpOption\fP *_opt) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_addTcpOption\fP (\fBTcpHeader\fP *_self, const u_int8_t _kind, const u_int8_t _length, void *_value) __attribute__((nonnull(1)))"
.br
.ti -1c
.RI "void \fBTcpHeader_setTcpOptions\fP (\fBTcpHeader\fP *_self, struct \fBTcpOption\fP *_opts[], const int _n) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int8_t \fBTcpHeader_mergeControlBits\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_encode\fP (\fBTcpHeader\fP *_self, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_decode\fP (\fBTcpHeader\fP *_self, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_printInfo\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "size_t \fBTcpHeader_getHeaderSize\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpHeader_deleteTcpOptions\fP (\fBTcpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBTcpPacket\fP * \fBTcpPacket_new_s\fP (const size_t _size) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBTcpPacket\fP * \fBTcpPacket_new\fP () __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBTcpPacket_delete\fP (\fBTcpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpPacket_setHeader\fP (\fBTcpPacket\fP *_self, \fBTcpHeader\fP *_hdr) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpPacket_fillHeader\fP (\fBTcpPacket\fP *_self, u_int16_t _srcport, u_int16_t _dstport, u_int32_t _seqnum, u_int32_t _acknum, u_int8_t _offset, struct \fBControlBits\fP _cbits, u_int16_t _window, u_int16_t _checksum, u_int16_t _urgpntr, struct \fBTcpOption\fP *_opts[], int _nopts) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBTcpPacket_fillPayload\fP (\fBTcpPacket\fP *_self, const char *_payload, const size_t _size) __attribute__((nonnull))"
.br
.ti -1c
.RI "size_t \fBTcpPacket_getPacketSize\fP (\fBTcpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "int \fBTcpPacket_getNumberOfOptions\fP (\fBTcpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int8_t \fBTcpPacket_getOptionSize_bytes\fP (\fBTcpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBByteBuffer\fP * \fBTcpPacket_encode\fP (\fBTcpPacket\fP *_self) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBTcpPacket_encode_b\fP (\fBTcpPacket\fP *_self, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBTcpPacket\fP * \fBTcpPacket_decode\fP (\fBByteBuffer\fP *_buffer) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBPseudoHeader_create\fP (const \fBIpPacket\fP *_pckt, struct \fBPseudoHeader\fP *_ph, const size_t _size) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBPseudoHeader_encode\fP (const struct \fBPseudoHeader\fP *_ph, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_setVersion\fP (\fBIpHeader\fP *_self, const u_int8_t _version) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_setDifferentiatedServiceField\fP (\fBIpHeader\fP *_self, const u_int8_t _dsf) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_setTotalLength\fP (\fBIpHeader\fP *_self, const u_int16_t _total_length) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_setIdentfication\fP (\fBIpHeader\fP *_self, const u_int16_t _identification) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_setFlagOffField\fP (\fBIpHeader\fP *_self, const u_int16_t _flagoff) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_setTimeToLive\fP (\fBIpHeader\fP *_self, const u_int8_t _time_to_live) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_setProtocol\fP (\fBIpHeader\fP *_self, const u_int8_t _protocol) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_setHeaderChecksum\fP (\fBIpHeader\fP *_self, const u_int16_t _checksum) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_setSourceAddress\fP (\fBIpHeader\fP *_self, const u_int32_t _srcaddres) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_setDestinationAddress\fP (\fBIpHeader\fP *_self, const u_int32_t _dstaddress) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int8_t \fBIpHeader_getVersion\fP (const \fBIpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int8_t \fBIpHeader_getInternetHeaderLength\fP (const \fBIpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int8_t \fBIpHeader_getDSCP\fP (const \fBIpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int8_t \fBIpHeader_getECN\fP (const \fBIpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int8_t \fBIpHeader_getFlags\fP (const \fBIpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int8_t \fBIpHeader_getFragmentOffset\fP (const \fBIpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_encode_b\fP (const \fBIpHeader\fP *_self, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBByteBuffer\fP * \fBIpHeader_encode\fP (const \fBIpHeader\fP *_self) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_decode\fP (\fBIpHeader\fP *_self, \fBByteBuffer\fP *_buffer) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpHeader_printInfo\fP (const \fBIpHeader\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int16_t \fBcomputeFlagOff\fP (const int _x, const int _d, const int _m, const int _offset)"
.br
.ti -1c
.RI "u_int8_t \fBcomputeDifferentiatedServiceField\fP (const int _dscp, const int _ecn)"
.br
.ti -1c
.RI "void \fBconvertFlagToBin\fP (const u_int8_t _flags, char *_out) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBIpPacket\fP * \fBIpPacket_new\fP () __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBIpPacket\fP * \fBIpPacket_newIcmp\fP (const u_int8_t _type, const u_int8_t _code, const size_t _size) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBIpPacket\fP * \fBIpPacket_newUdp\fP (const size_t _size) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBIpPacket\fP * \fBIpPacket_newTcp\fP (const size_t _size) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBIpPacket_delete\fP (\fBIpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpPacket_setHeader\fP (\fBIpPacket\fP *_self, \fBIpHeader\fP *_iphdr) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpPacket_fillHeader\fP (\fBIpPacket\fP *_self, const u_int8_t _version, const u_int8_t _dsf, const u_int16_t _tlen, const u_int16_t _id, const u_int16_t _flagoff, const u_int8_t _ttl, const u_int8_t _protocol, const u_int16_t _checksum, const u_int32_t _srcaddr, const u_int32_t _dstaddr) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int16_t \fBIpPacket_getPayloadSize\fP (const \fBIpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "\fBIcmpPacket\fP * \fBIpPacket_getIcmpPacket\fP (const \fBIpPacket\fP *_self) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBUdpPacket\fP * \fBIpPacket_getUdpPacket\fP (const \fBIpPacket\fP *_self) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBTcpPacket\fP * \fBIpPacket_getTcpPacket\fP (const \fBIpPacket\fP *_self) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBByteBuffer\fP * \fBIpPacket_encode\fP (const \fBIpPacket\fP *_self) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBIpPacket\fP * \fBIpPacket_decodeIcmp\fP (\fBByteBuffer\fP *_buffer) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBIpPacket\fP * \fBIpPacket_decodeUdp\fP (\fBByteBuffer\fP *_buffer) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "\fBIpPacket\fP * \fBIpPacket_decodeTcp\fP (\fBByteBuffer\fP *_buffer) __attribute__((nonnull)) __attribute__((returns_nonnull))"
.br
.ti -1c
.RI "void \fBIpPacket_wrapIcmp\fP (\fBIpPacket\fP *_self, \fBIcmpPacket\fP *_icmppckt) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpPacket_wrapUdp\fP (\fBIpPacket\fP *_self, \fBUdpPacket\fP *_udppckt) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpPacket_wrapTcp\fP (\fBIpPacket\fP *_self, \fBTcpPacket\fP *_tcppckt) __attribute__((nonnull))"
.br
.ti -1c
.RI "void \fBIpPacket_computeChecksum\fP (\fBIpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int16_t \fBIpPacket_computeIcmpChecksum\fP (\fBIpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int16_t \fBIpPacket_computeUdpChecksum\fP (\fBIpPacket\fP *_self) __attribute__((nonnull))"
.br
.ti -1c
.RI "u_int16_t \fBIpPacket_computeTcpChecksum\fP (\fBIpPacket\fP *_self) __attribute__((nonnull))"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define D_FLAG_NOT_SET   0"

.PP
Definition at line \fB91\fP of file \fBip\&.h\fP\&.
.SS "#define D_FLAG_SET   0x02"

.PP
Definition at line \fB93\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_DESTINATION_UNREACHABLE_TYPE   0x03"

.PP
Definition at line \fB40\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_ECHO_CODE   0x0"

.PP
Definition at line \fB57\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_ECHO_REPLY_TYPE   0x00"

.PP
Definition at line \fB39\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_ECHO_TYPE   0x08"

.PP
Definition at line \fB43\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_FRAGMENTATION_NEEDED_CODE   0x04"

.PP
Definition at line \fB54\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_HEADER_MAX_SIZE   0x08"

.PP
Definition at line \fB36\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_HOST_UNREACHABLE_CODE   0x01"

.PP
Definition at line \fB51\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_INFORMATION_REPLY_TYPE   0x10"

.PP
Definition at line \fB47\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_INFORMATION_REQUEST_TYPE   0x0f"

.PP
Definition at line \fB46\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_NET_UNREACHABLE_CODE   0x00"

.PP
Definition at line \fB50\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_PARAMETER_PROBLEM_TYPE   0x0c"

.PP
Definition at line \fB45\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_PAYLOAD_MAXIMUM_SIZE   0xffe3"

.PP
Definition at line \fB58\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_PORT_UNREACHABLE_CODE   0x03"

.PP
Definition at line \fB53\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_PROTOCOL_UNREACHABLE_CODE   0x02"

.PP
Definition at line \fB52\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_REDIRECT_TYPE   0x05"

.PP
Definition at line \fB42\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_SOURCE_QUENCH_TYPE   0x04"

.PP
Definition at line \fB41\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_SOURCE_ROUTE_FAILED_CODE   0x05"

.PP
Definition at line \fB55\fP of file \fBip\&.h\fP\&.
.SS "#define ICMP_TIME_EXCEEEDED_TYPE   0x0b"

.PP
Definition at line \fB44\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF11   0x0a"

.PP
Definition at line \fB107\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF12   0x0c"

.PP
Definition at line \fB108\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF13   0x0e"

.PP
Definition at line \fB109\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF21   0x12"

.PP
Definition at line \fB110\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF22   0x14"

.PP
Definition at line \fB111\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF23   0x16"

.PP
Definition at line \fB112\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF31   0x1a"

.PP
Definition at line \fB113\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF32   0x1c"

.PP
Definition at line \fB114\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF33   0x1e"

.PP
Definition at line \fB115\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF41   0x22"

.PP
Definition at line \fB116\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF42   0x24"

.PP
Definition at line \fB117\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_AF43   0x26"

.PP
Definition at line \fB118\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_CS0   0x00"

.PP
Definition at line \fB99\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_CS1   0x08"

.PP
Definition at line \fB100\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_CS2   0x10"

.PP
Definition at line \fB101\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_CS3   0x18"

.PP
Definition at line \fB102\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_CS4   0x20"

.PP
Definition at line \fB103\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_CS5   0x28"

.PP
Definition at line \fB104\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_CS6   0x30"

.PP
Definition at line \fB105\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_CS7   0x38"

.PP
Definition at line \fB106\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_EF   0x2e"

.PP
Definition at line \fB119\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_DSCP_VOICE_ADMIT   0x2c"

.PP
Definition at line \fB120\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_ECN_CE   0x03"

.PP
Definition at line \fB126\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_ECN_ECT0   0x02"

.PP
Definition at line \fB125\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_ECN_ECT1   0x01"

.PP
Definition at line \fB124\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_ECN_NECT   0x00"

.PP
Definition at line \fB123\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_FLAG( _x,  _d,  _m)   (_x + _d + _m)"

.PP
Definition at line \fB96\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_ICMP_PROTOCOL_CODE   0x01"

.PP
Definition at line \fB129\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_SIZE   0x14"

.PP
Definition at line \fB88\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_TCP_PROTOCOL_CODE   0x06"

.PP
Definition at line \fB131\fP of file \fBip\&.h\fP\&.
.SS "#define IP_HEADER_UDP_PROTOCOL_CODE   0x11"

.PP
Definition at line \fB130\fP of file \fBip\&.h\fP\&.
.SS "#define IP_PAYLOAD_MAX_SIZE   65515"

.PP
Definition at line \fB141\fP of file \fBip\&.h\fP\&.
.SS "#define IPv4   0x4"

.PP
Definition at line \fB86\fP of file \fBip\&.h\fP\&.
.SS "#define IPv6   0x6"

.PP
Definition at line \fB87\fP of file \fBip\&.h\fP\&.
.SS "#define M_FLAG_NOT_SET   0"

.PP
Definition at line \fB92\fP of file \fBip\&.h\fP\&.
.SS "#define M_FLAG_SET   0x01"

.PP
Definition at line \fB94\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_ACK_SET   0x10"

.PP
Definition at line \fB70\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_CWR_SET   0x80"

.PP
Definition at line \fB73\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_ECE_SET   0x40"

.PP
Definition at line \fB72\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_FIN_SET   0x01"

.PP
Definition at line \fB66\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_NOT_SET   0x00"

.PP
Definition at line \fB65\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_OPTION_KIND_MSS   0x02"

.PP
Definition at line \fB80\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_OPTION_KIND_NOOP   0x01"

.PP
Definition at line \fB79\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_OPTION_KIND_SACK_PERM   0x04"

.PP
Definition at line \fB82\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_OPTION_KIND_TIMESTAMP   0x08"

.PP
Definition at line \fB83\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_OPTION_KIND_WIN_SCALE   0x03"

.PP
Definition at line \fB81\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_OPTIONS_MAX_SIZE   0x14"

.PP
Definition at line \fB76\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_PSEUDO_HEADER_SIZE   0x0c"

.PP
Definition at line \fB75\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_PSH_SET   0x08"

.PP
Definition at line \fB69\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_RST_SET   0x04"

.PP
Definition at line \fB68\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_SYN_SET   0x02"

.PP
Definition at line \fB67\fP of file \fBip\&.h\fP\&.
.SS "#define TCP_URG_SET   0x20"

.PP
Definition at line \fB71\fP of file \fBip\&.h\fP\&.
.SS "#define TTL_DEFAULT_VALUE   0x80"

.PP
Definition at line \fB135\fP of file \fBip\&.h\fP\&.
.SS "#define UDP_HEADER_SIZE   0x08"

.PP
Definition at line \fB60\fP of file \fBip\&.h\fP\&.
.SS "#define UDP_PAYLOAD_MAX_SIZE   0xffe3"

.PP
Definition at line \fB61\fP of file \fBip\&.h\fP\&.
.SS "#define UDP_PSEUDO_HEADER_SIZE   0x0c"

.PP
Definition at line \fB62\fP of file \fBip\&.h\fP\&.
.SS "#define X_FLAG_NOT_SET   0"

.PP
Definition at line \fB90\fP of file \fBip\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "u_int8_t computeDifferentiatedServiceField (const int _dscp, const int _ecn)\fR [extern]\fP"
Compute the value for the DSF Field by combining the input DSCP and ECN values 
.SS "u_int16_t computeFlagOff (const int _x, const int _d, const int _m, const int _offset)\fR [extern]\fP"
Compute the value for the Flags + Fragment Offset field by combining the three input flags into a single value and then combining this single value with the input fragment offset into the final value 
.SS "void ControlBits_decode (struct \fBControlBits\fP * _cbits, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Fill the ControlBit structure with the content of the \fBByteBuffer\fP 
.SS "void ControlBits_fromValue (const u_int8_t _bits, struct \fBControlBits\fP * _cbits)\fR [extern]\fP"
Converts the input integer into \fBControlBits\fP\&. For example, consider that the Control Bits field is 8 bit long, which means that the greatest number that can fit in is 2^8 - 1\&. Consdering any number between [0, 2^8), it is possible to convert it into flags just by converting it into binary\&.
.PP
Hence, this function fills each field of the input structure \fR_cbits\fP\&.
.PP
\fBParameters\fP
.RS 4
\fI_bits\fP a value between 0 and 2^8 - 1 
.br
\fI_cbits\fP a poiter to a \fBControlBits\fP structure 
.RE
.PP

.SS "void ControlBits_toBin (const struct \fBControlBits\fP * _cbits, char * _out)\fR [extern]\fP"
Converts the control bits into a string of binary values 
.SS "void convertFlagToBin (const u_int8_t _flags, char * _out)\fR [extern]\fP"
Converts the IP Header flags into a binary string (i\&.e\&., 2 -> 010) 
.SS "void IcmpHeader_createHeader_Echo (\fBIcmpHeader\fP * _self)\fR [extern]\fP"
Creates and fill the header with the Identification and Sequence Number fields 
.SS "void IcmpHeader_createHeader_Mtu (\fBIcmpHeader\fP * _self)\fR [extern]\fP"
Creates and fill the header with the Next Hop MTU field 
.SS "void IcmpHeader_createHeader_Redirect (\fBIcmpHeader\fP * _self)\fR [extern]\fP"
Creates and fill the header with the gateway field 
.SS "void IcmpHeader_createHeader_Unused (\fBIcmpHeader\fP * _self)\fR [extern]\fP"
Creates and fill the header with Unused bytes 
.SS "void IcmpHeader_decode (\fBIcmpHeader\fP * _hdr, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Decode the input bytes into an ICMP Header 
.SS "void IcmpHeader_encode (const \fBIcmpHeader\fP * _self, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Encode the Icmp Header into a buffer of bytes filling the input \fBByteBuffer\fP\&. Notice that all the elements with size grater than 1 are converted from little-endian into big-endian (network byte order) 
.SS "\fBByteBuffer\fP * IcmpHeader_encode_b (const \fBIcmpHeader\fP * _self)\fR [extern]\fP"
Perform the encoding as the \fRIcmpHeader_encode\fP function and also returns the \fBByteBuffer\fP 
.SS "void IcmpHeader_new (\fBIcmpHeader\fP * _hdr, const u_int8_t _type, const u_int8_t _code)\fR [extern]\fP"
Return a pointer to an \fBIcmpHeader\fP struct initialized given the input type 
.SS "void IcmpHeader_printInfo (const \fBIcmpHeader\fP * _self)\fR [extern]\fP"
Print all the Header fields with corresponding values 
.SS "void IcmpHeader_printInfo_Mtu (const \fBIcmpHeader\fP * _self)\fR [extern]\fP"
Prints header information in the case the Mtu format is chosen\&. This function is already called in IcmpHeader_printInfo 
.SS "void IcmpHeader_printInfo_Redirect (const \fBIcmpHeader\fP * _self)\fR [extern]\fP"
Prints header information in the case the Echo Req/Rep format is chosen\&. This function is already called in IcmpHeader_printInfo 
.SS "void IcmpHeader_printInfo_Unused (const \fBIcmpHeader\fP * _self)\fR [extern]\fP"
Prints header information in the case the Redirect header format is chosen\&. This function is already called in IcmpHeader_printInfo 
.SS "void IcmpHeader_setChecksum (\fBIcmpHeader\fP * _self, const u_int16_t _checksum)\fR [extern]\fP"
Set the Checksum field of the ICMP header with the input checksum 
.SS "void IcmpHeader_setCode (\fBIcmpHeader\fP * _self, const u_int8_t _code)\fR [extern]\fP"
Set the Code field of the ICMP header with the input Code 
.SS "void IcmpHeader_setGateway (\fBIcmpHeader\fP * _self, const u_int32_t _gateway)\fR [extern]\fP"
Set the Gateway field of the ICMP header with the input gateway address if the given ICMP Type corresponds to the correct ICMP Header format\&. If it is not, then an error is raise and the process exit with failure 
.SS "void IcmpHeader_setIdentifier (\fBIcmpHeader\fP * _self, const u_int16_t _id)\fR [extern]\fP"
Set the Identifier field of the ICMP header with the input identifier if the given ICMP Type corresponds to the correct ICMP Header format\&. If it is not, then an error is raise and the process exit with failure 
.SS "void IcmpHeader_setNextHopMtu (\fBIcmpHeader\fP * _self, const u_int16_t _mtu)\fR [extern]\fP"
Set the Next Hop MTU for Destination Unreachable message with Fragmentation Needed 
.SS "void IcmpHeader_setSequenceNumber (\fBIcmpHeader\fP * _self, const u_int16_t _seqnum)\fR [extern]\fP"
Set the Sequence Number field of the ICMP header with the input sequence number if the given ICMP Type corresponds to the correct ICMP Header format\&. If it is not, then an error is raise and the process exit with failure 
.SS "void IcmpHeader_setType (\fBIcmpHeader\fP * _self, const u_int8_t _type)\fR [extern]\fP"
Set the Type field of the ICMP header with the input Type 
.SS "\fBIcmpPacket\fP * IcmpPacket_decode (\fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Decode the input \fBByteBuffer\fP into a ICMP Packet 
.SS "void IcmpPacket_delete (\fBIcmpPacket\fP * _self)\fR [extern]\fP"
Free the memory allocated for the ICMP Packet 
.SS "\fBByteBuffer\fP * IcmpPacket_encode (const \fBIcmpPacket\fP * _self)\fR [extern]\fP"
Creates and Encodes the entire ICMP Packet into a \fBByteBuffer\fP 
.SS "void IcmpPacket_encode_b (const \fBIcmpPacket\fP * _self, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Encodes the entire ICMP Packet into a \fBByteBuffer\fP 
.SS "void IcmpPacket_fillHeader_Echo (\fBIcmpPacket\fP * _self, const u_int16_t _checksum, const u_int16_t _id, const u_int16_t _seqnum)\fR [extern]\fP"
Fill the Header of the ICMP Packet with the Code, Identifier and Sequence Number\&. This version of the \fRfillHeader\fP function is reserved for ICMP Header with 32 bits divided into Identifier (16 bits) and Sequence Number (16 bits)\&. 
.SS "void IcmpPacket_fillHeader_Mtu (\fBIcmpPacket\fP * _self, const u_int16_t _checksum, const u_int16_t _data)\fR [extern]\fP"
Fill the header of the ICMP with 32 of Optinal datas divided into: 16 unused (zeros) bits and remaining 16 bits used for some generic purpose, like MTU Path Discovery\&.
.PP
\fBParameters\fP
.RS 4
\fI_data\fP Represents the Next Hop MTU 
.RE
.PP

.SS "void IcmpPacket_fillHeader_Redirect (\fBIcmpPacket\fP * _self, const u_int16_t _checksum, const u_int32_t _gateway)\fR [extern]\fP"
Fill the Header of the ICMP Packet with the Code and the Gateway\&. This version of the \fRfillHeader\fP function is reserved for ICMP Header with 32 bits for the gateway address 
.SS "void IcmpPacket_fillHeader_Unused (\fBIcmpPacket\fP * _self, const u_int16_t _checksum)\fR [extern]\fP"
Fill the Header of the ICMP Packet with the Code\&. This version of the \fRfillHeader\fP function is reserved for ICMP Header with 32 bits unused 
.SS "void IcmpPacket_fillPayload (\fBIcmpPacket\fP * _self, const char * _payload, const size_t _size)\fR [extern]\fP"
Fill the ICMP Packet payload with input buffer and set a new size 
.SS "size_t IcmpPacket_getPacketSize (const \fBIcmpPacket\fP * _self)\fR [extern]\fP"
Returns the entire size of the ICMP Packet (Header + Payload) 
.SS "\fBIcmpPacket\fP * IcmpPacket_new (const u_int8_t _type, const u_int8_t _code, const size_t _size)\fR [extern]\fP"
Create a new ICMP Packet initialized according to input Type and Payload Size 
.SS "\fBIcmpPacket\fP * IcmpPacket_new_tnc (const u_int8_t _type, const u_int8_t _code)\fR [extern]\fP"
Create a new ICMP Packet initialized according to input Type 
.SS "void IcmpPacket_setHeader (\fBIcmpPacket\fP * _self, \fBIcmpHeader\fP * _hdr)\fR [extern]\fP"
Set a new Header for the ICMP Packet\&. 
.SS "void IpHeader_decode (\fBIpHeader\fP * _self, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Decode the input \fBByteBuffer\fP into an IP Header 
.SS "\fBByteBuffer\fP * IpHeader_encode (const \fBIpHeader\fP * _self)\fR [extern]\fP"
Encode the IP header into a \fBByteBuffer\fP and returns the \fBByteBuffer\fP 
.SS "void IpHeader_encode_b (const \fBIpHeader\fP * _self, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Encode the IP header into a \fBByteBuffer\fP 
.SS "u_int8_t IpHeader_getDSCP (const \fBIpHeader\fP * _self)\fR [extern]\fP"
Returns the Differentiated Service Code Point from the DSF field 
.SS "u_int8_t IpHeader_getECN (const \fBIpHeader\fP * _self)\fR [extern]\fP"
Returns the Explicit Congestion Notification value from the DSF field 
.SS "u_int8_t IpHeader_getFlags (const \fBIpHeader\fP * _self)\fR [extern]\fP"
Returns the Flags value from the IP Header 
.SS "u_int8_t IpHeader_getFragmentOffset (const \fBIpHeader\fP * _self)\fR [extern]\fP"
Returns the Fragment Offset value from the IP Header 
.SS "u_int8_t IpHeader_getInternetHeaderLength (const \fBIpHeader\fP * _self)\fR [extern]\fP"
Returns the IHL Value from the IP Header 
.SS "u_int8_t IpHeader_getVersion (const \fBIpHeader\fP * _self)\fR [extern]\fP"
Returns the version of the IP 
.SS "void IpHeader_printInfo (const \fBIpHeader\fP * _self)\fR [extern]\fP"
Prints the IP Header fields and values 
.SS "void IpHeader_setDestinationAddress (\fBIpHeader\fP * _self, const u_int32_t _dstaddress)\fR [extern]\fP"
Set the Destination Address field of the IP Header 
.SS "void IpHeader_setDifferentiatedServiceField (\fBIpHeader\fP * _self, const u_int8_t _dsf)\fR [extern]\fP"
Set the differentiated Service field In the IP Header 
.SS "void IpHeader_setFlagOffField (\fBIpHeader\fP * _self, const u_int16_t _flagoff)\fR [extern]\fP"
Set the Flag and the Fragment Offset field 
.SS "void IpHeader_setHeaderChecksum (\fBIpHeader\fP * _self, const u_int16_t _checksum)\fR [extern]\fP"
Set the Checksum of the Header 
.SS "void IpHeader_setIdentfication (\fBIpHeader\fP * _self, const u_int16_t _identification)\fR [extern]\fP"
Set the Identification field of the IP Header 
.SS "void IpHeader_setProtocol (\fBIpHeader\fP * _self, const u_int8_t _protocol)\fR [extern]\fP"
Set the Protocol Field 
.SS "void IpHeader_setSourceAddress (\fBIpHeader\fP * _self, const u_int32_t _srcaddres)\fR [extern]\fP"
Set the source Address field of the IP Header 
.SS "void IpHeader_setTimeToLive (\fBIpHeader\fP * _self, const u_int8_t _time_to_live)\fR [extern]\fP"
Set the TTL Field 
.SS "void IpHeader_setTotalLength (\fBIpHeader\fP * _self, const u_int16_t _total_length)\fR [extern]\fP"
Set the Total Length field of the IP Header 
.SS "void IpHeader_setVersion (\fBIpHeader\fP * _self, const u_int8_t _version)\fR [extern]\fP"
Set the IP Version field and the IHL (always 5) field 
.SS "void IpPacket_computeChecksum (\fBIpPacket\fP * _self)\fR [extern]\fP"
Compute and set the checksum for TCP/UDP/ICMP Packet 
.SS "u_int16_t IpPacket_computeIcmpChecksum (\fBIpPacket\fP * _self)\fR [extern]\fP"
Compute the checksum for an ICMP Packet 
.SS "u_int16_t IpPacket_computeTcpChecksum (\fBIpPacket\fP * _self)\fR [extern]\fP"
Compute the checksum for a TCP Packet 
.SS "u_int16_t IpPacket_computeUdpChecksum (\fBIpPacket\fP * _self)\fR [extern]\fP"
Compute the checksum for an UDP Packet 
.SS "\fBIpPacket\fP * IpPacket_decodeIcmp (\fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Decode the input ICMP \fBByteBuffer\fP into an ICMP packet 
.SS "\fBIpPacket\fP * IpPacket_decodeTcp (\fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Decode the input TCP \fBByteBuffer\fP into an IP packet 
.SS "\fBIpPacket\fP * IpPacket_decodeUdp (\fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Decode the input UDP \fBByteBuffer\fP into an IP packet 
.SS "void IpPacket_delete (\fBIpPacket\fP * _self)\fR [extern]\fP"
Free the memory allocated for the input IP Packet 
.SS "\fBByteBuffer\fP * IpPacket_encode (const \fBIpPacket\fP * _self)\fR [extern]\fP"
Encode the IP Packet into a \fBByteBuffer\fP 
.SS "void IpPacket_fillHeader (\fBIpPacket\fP * _self, const u_int8_t _version, const u_int8_t _dsf, const u_int16_t _tlen, const u_int16_t _id, const u_int16_t _flagoff, const u_int8_t _ttl, const u_int8_t _protocol, const u_int16_t _checksum, const u_int32_t _srcaddr, const u_int32_t _dstaddr)\fR [extern]\fP"
Fill the header of the input IP Packet with all the values given as input 
.SS "\fBIcmpPacket\fP * IpPacket_getIcmpPacket (const \fBIpPacket\fP * _self)\fR [extern]\fP"
Returns the ICMP Packet encoded into the IP Packet Payload 
.SS "u_int16_t IpPacket_getPayloadSize (const \fBIpPacket\fP * _self)\fR [extern]\fP"
Returns the payload size of the input IP Packet 
.SS "\fBTcpPacket\fP * IpPacket_getTcpPacket (const \fBIpPacket\fP * _self)\fR [extern]\fP"
Returns the TCP Packet encoded into the IP Packet Payload 
.SS "\fBUdpPacket\fP * IpPacket_getUdpPacket (const \fBIpPacket\fP * _self)\fR [extern]\fP"
Returns the UDP Packet encoded into the IP Packet Payload 
.SS "\fBIpPacket\fP * IpPacket_new ()\fR [extern]\fP"
Creates and returns a new empty IP packet 
.SS "\fBIpPacket\fP * IpPacket_newIcmp (const u_int8_t _type, const u_int8_t _code, const size_t _size)\fR [extern]\fP"
Create and returns a new ICMP Packet 
.SS "\fBIpPacket\fP * IpPacket_newTcp (const size_t _size)\fR [extern]\fP"
Create and returns a new TCP Packet 
.SS "\fBIpPacket\fP * IpPacket_newUdp (const size_t _size)\fR [extern]\fP"
Create and returns a new UDP packet 
.SS "void IpPacket_setHeader (\fBIpPacket\fP * _self, \fBIpHeader\fP * _iphdr)\fR [extern]\fP"
Set a new header for the IP Packet\&. 
.SS "void IpPacket_wrapIcmp (\fBIpPacket\fP * _self, \fBIcmpPacket\fP * _icmppckt)\fR [extern]\fP"
Wrap the input ICMP Packet into the payload of the input IP Packet 
.SS "void IpPacket_wrapTcp (\fBIpPacket\fP * _self, \fBTcpPacket\fP * _tcppckt)\fR [extern]\fP"
Wrap the input TCP Packet into the payload of the input IP Packet 
.SS "void IpPacket_wrapUdp (\fBIpPacket\fP * _self, \fBUdpPacket\fP * _udppckt)\fR [extern]\fP"
Wrap the input UDP Packet into the payload of the input IP Packet 
.SS "void PseudoHeader_create (const \fBIpPacket\fP * _pckt, struct \fBPseudoHeader\fP * _ph, const size_t _size)\fR [extern]\fP"
Fill the pseudo header with the information from the Ip Packet Header and a size value, corresponding of the size of the entire underlying packet\&. 
.SS "void PseudoHeader_encode (const struct \fBPseudoHeader\fP * _ph, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Fill the input \fBByteBuffer\fP with informations from the Pseudo Header 
.SS "void TcpHeader_addTcpOption (\fBTcpHeader\fP * _self, const u_int8_t _kind, const u_int8_t _length, void * _value)\fR [extern]\fP"
Construct and add a new Tcp Option to the current Tcp Header\&. 
.SS "void TcpHeader_addTcpOption_o (\fBTcpHeader\fP * _self, struct \fBTcpOption\fP * _opt)\fR [extern]\fP"
Add a Tcp Option to the current Tcp Header\&. 
.SS "void TcpHeader_decode (\fBTcpHeader\fP * _self, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Decode the input \fBByteBuffer\fP into a TCP Header 
.SS "void TcpHeader_deleteTcpOptions (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Free the memory allocated for each Tcp Option 
.SS "void TcpHeader_encode (\fBTcpHeader\fP * _self, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Encode the input TCP Header into a \fBByteBuffer\fP 
.SS "size_t TcpHeader_getHeaderSize (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Returns the size of the tcp header 
.SS "u_int8_t TcpHeader_mergeControlBits (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Sum all the control bits together in an unsigned short value 
.SS "void TcpHeader_printInfo (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Print informations about the header, in particular all the fields 
.SS "void TcpHeader_setAcknowledgmentFieldFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Set the ACK flag of the input TCP Header 
.SS "void TcpHeader_setAcknowledgmentNumber (\fBTcpHeader\fP * _self, u_int32_t _acknum)\fR [extern]\fP"
Set the Acknowledgment number of input Tcp Header 
.SS "void TcpHeader_setChecksum (\fBTcpHeader\fP * _self, u_int16_t _checksum)\fR [extern]\fP"
Set the checksum of the input TCP Header 
.SS "void TcpHeader_setCongestionWindowReducedFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Set the CWR Flag of the input TCP Header 
.SS "void TcpHeader_setControlBits (\fBTcpHeader\fP * _self, struct \fBControlBits\fP _cbits)\fR [extern]\fP"
Set the Controlbits of the input header from the input Control bits structure 
.SS "void TcpHeader_setDataOffset (\fBTcpHeader\fP * _self, u_int8_t _srcport)\fR [extern]\fP"
Set the Data Offset of the input Tcp Header 
.SS "void TcpHeader_setDestinationPort (\fBTcpHeader\fP * _self, u_int16_t _dstport)\fR [extern]\fP"
Set the destination port of the input Tcp Header 
.SS "void TcpHeader_setECNEchoFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Set the ECE Flag of the input TCP Header 
.SS "void TcpHeader_setFinFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Set the FIN Flag of the input TCP Header 
.SS "void TcpHeader_setPushFunctionFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Set the PSH Flag of the input TCP Header 
.SS "void TcpHeader_setResetConnectionFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Set the RST Flag of the input TCP Header 
.SS "void TcpHeader_setSequenceNumber (\fBTcpHeader\fP * _self, u_int32_t _seqnum)\fR [extern]\fP"
Set the sequence number of the input Tcp Header 
.SS "void TcpHeader_setSourcePort (\fBTcpHeader\fP * _self, u_int16_t _srcport)\fR [extern]\fP"
Set the source port of the input Tcp Header 
.SS "void TcpHeader_setSynchronizeFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Set the SYN Flag of the input TCP Header 
.SS "void TcpHeader_setTcpOptions (\fBTcpHeader\fP * _self, struct \fBTcpOption\fP * _opts[], const int _n)\fR [extern]\fP"
Set a new set of options into the tcp header\&. \fR_n\fP is the length of the vector 
.SS "void TcpHeader_setUrgentPointer (\fBTcpHeader\fP * _self, u_int16_t _urgpntr)\fR [extern]\fP"
Set the urgent pointer field of the input TCP Header 
.SS "void TcpHeader_setUrgentPointerFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Set the URG Flag of the input TCP Header 
.SS "void TcpHeader_setWindowSize (\fBTcpHeader\fP * _self, u_int16_t _window)\fR [extern]\fP"
Set the Window size of the input Tcp Header 
.SS "void TcpHeader_unsetAcknowledgmentFieldFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Unset the ACK flag of the input TCP Header 
.SS "void TcpHeader_unsetCongestionWindowReducedFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Unset the CWR Flag of the input TCP Header 
.SS "void TcpHeader_unsetECNEchoFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Unset the ECE Flag of the input TCP Header 
.SS "void TcpHeader_unsetFinFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Unset the FIN Flag of the input TCP Header 
.SS "void TcpHeader_unsetPushFunctionFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Unset the PSH Flag of the input TCP Header 
.SS "void TcpHeader_unsetResetConnectionFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Unset the RST Flag of the input TCP Header 
.SS "void TcpHeader_unsetSynchronizeFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Unset the SYN Flag of the input TCP Header 
.SS "void TcpHeader_unsetUrgentPointerFlag (\fBTcpHeader\fP * _self)\fR [extern]\fP"
Unset the URG Flag of the input TCP Header 
.SS "struct \fBTcpOption\fP * TcpOption_new (const u_int8_t _kind, const u_int8_t _length, void * _value)\fR [extern]\fP"
Create a new \fBTcpOption\fP given the values as input\&. Notice that \fR_value\fP can be NULL\&. 
.SS "struct \fBTcpOption\fP * TcpOption_newMss (u_int16_t _mss)\fR [extern]\fP"
Create the TCP Option reserved for Maximum Segment Size 
.SS "struct \fBTcpOption\fP * TcpOption_newNoOperation (void )\fR [extern]\fP"
Create the TCP Option reserved for No-operation 
.SS "struct \fBTcpOption\fP * TcpOption_newSackPermitted (void )\fR [extern]\fP"
Create the TCP Option reserved for SACK Permitted 
.SS "struct \fBTcpOption\fP * TcpOption_newTimestamps (u_int32_t _tsval, u_int32_t _tsecr)\fR [extern]\fP"
Create the TCP Option reserved for Timestamps 
.SS "struct \fBTcpOption\fP * TcpOption_newWindowScale (u_int8_t _scale)\fR [extern]\fP"
Create the TCP Option reserved for Window Scale 
.SS "void TcpOptions_copy (struct \fBTcpOption\fP ** _src, struct \fBTcpOption\fP ** _dst, const int _n)\fR [extern]\fP"
Copy all the options in \fR_src\fP into \fR_dst\fP\&. 
.SS "void TcpOptions_delete (struct \fBTcpOption\fP ** _opts, const int _n)\fR [extern]\fP"
Free the memory allocate for each Tcp Option 
.SS "\fBTcpPacket\fP * TcpPacket_decode (\fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Decodes a \fBByteBuffer\fP into a TCP Packet 
.SS "void TcpPacket_delete (\fBTcpPacket\fP * _self)\fR [extern]\fP"
Free the memory allocated for the TCP Packet 
.SS "\fBByteBuffer\fP * TcpPacket_encode (\fBTcpPacket\fP * _self)\fR [extern]\fP"
Encodes the TCP Packet into a \fBByteBuffer\fP and returns it 
.SS "void TcpPacket_encode_b (\fBTcpPacket\fP * _self, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Encodes the TCP Packet into the input \fBByteBuffer\fP 
.SS "void TcpPacket_fillHeader (\fBTcpPacket\fP * _self, u_int16_t _srcport, u_int16_t _dstport, u_int32_t _seqnum, u_int32_t _acknum, u_int8_t _offset, struct \fBControlBits\fP _cbits, u_int16_t _window, u_int16_t _checksum, u_int16_t _urgpntr, struct \fBTcpOption\fP * _opts[], int _nopts)\fR [extern]\fP"
Fill the TCP Packet Header with all values given as input 
.SS "void TcpPacket_fillPayload (\fBTcpPacket\fP * _self, const char * _payload, const size_t _size)\fR [extern]\fP"
Fill the TCP Packet payload with the given input data of input size 
.SS "int TcpPacket_getNumberOfOptions (\fBTcpPacket\fP * _self)\fR [extern]\fP"
Returns the number of Tcp options in the header 
.SS "u_int8_t TcpPacket_getOptionSize_bytes (\fBTcpPacket\fP * _self)\fR [extern]\fP"
Returns the number of bytes of the header assigned to Tcp Options 
.SS "size_t TcpPacket_getPacketSize (\fBTcpPacket\fP * _self)\fR [extern]\fP"
Returns the size of the packet Header + Payload 
.SS "\fBTcpPacket\fP * TcpPacket_new ()\fR [extern]\fP"
Create and returns a new TCP Packet 
.SS "\fBTcpPacket\fP * TcpPacket_new_s (const size_t _size)\fR [extern]\fP"
Create and returns a new TCP Packet given the input size 
.SS "void TcpPacket_setHeader (\fBTcpPacket\fP * _self, \fBTcpHeader\fP * _hdr)\fR [extern]\fP"
Set a new header to the TCP Packet copying the input one into the packet 
.SS "void UdpHeader_decode (\fBUdpHeader\fP * _self, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Decode a \fBByteBuffer\fP into an UDP Header 
.SS "void UdpHeader_encode (const \fBUdpHeader\fP * _self, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Encode the UDP Header into a \fBByteBuffer\fP 
.SS "\fBByteBuffer\fP * UdpHeader_encode__ (const \fBUdpHeader\fP * _self)\fR [extern]\fP"
Encode and returns the \fBByteBuffer\fP containing the UDP header 
.SS "void UdpHeader_printInfo (const \fBUdpHeader\fP * _self)\fR [extern]\fP"
Print all the Header fields with current values 
.SS "void UdpHeader_setChecksum (\fBUdpHeader\fP * _self, const u_int16_t _checksum)\fR [extern]\fP"
Set the Checksum field into the UDP Header 
.SS "void UdpHeader_setDestinationPort (\fBUdpHeader\fP * _self, const u_int16_t _dstport)\fR [extern]\fP"
Set the Destination Port field into the UDP Header 
.SS "void UdpHeader_setLength (\fBUdpHeader\fP * _self, const u_int16_t _length)\fR [extern]\fP"
Set the Length field into the UDP Header 
.SS "void UdpHeader_setSourcePort (\fBUdpHeader\fP * _self, const u_int16_t _srcport)\fR [extern]\fP"
Set the Source Port field into the UDP Header 
.SS "\fBUdpPacket\fP * UdpPacket_decode (\fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Decode a \fBByteBuffer\fP into a UDP Packet 
.SS "void UdpPacket_delete (\fBUdpPacket\fP * _self)\fR [extern]\fP"
Free the memory allocated for the input UDP Packet 
.SS "\fBByteBuffer\fP * UdpPacket_encode (const \fBUdpPacket\fP * _self)\fR [extern]\fP"
Encode the UDP Packet into a Byte Buffer 
.SS "void UdpPacket_encode_b (const \fBUdpPacket\fP * _self, \fBByteBuffer\fP * _buffer)\fR [extern]\fP"
Encode the UDP Packet into a Byte Buffer given as input 
.SS "void UdpPacket_fillHeader (\fBUdpPacket\fP * _self, const u_int16_t _srcport, const u_int16_t _dstport, const u_int16_t _length, const u_int16_t _checksum)\fR [extern]\fP"
Fill the header of the input UDP Packet given all its fields 
.SS "void UdpPacket_fillPayload (\fBUdpPacket\fP * _self, const char * _data, const size_t _size)\fR [extern]\fP"
Fill the payload of the UDP Packet with the input buffer of input size 
.SS "size_t UdpPacket_getPacketSize (const \fBUdpPacket\fP * _self)\fR [extern]\fP"
Returns the size of the entire packet 
.SS "size_t UdpPacket_getPayloadSize (const \fBUdpPacket\fP * _self)\fR [extern]\fP"
Returns the size of the payload inside the input UDP Packet 
.SS "\fBUdpPacket\fP * UdpPacket_new ()\fR [extern]\fP"
Creates and returns a new UDP Packet 
.SS "\fBUdpPacket\fP * UdpPacket_new_s (const size_t _size)\fR [extern]\fP"
Creates and returns a new UDP Packet with the payload initialized with input size 
.SS "void UdpPacket_setHeader (\fBUdpPacket\fP * _self, \fBUdpHeader\fP * _hdr)\fR [extern]\fP"
Set the header of the udp packet\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for libcnet from the source code\&.
